{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.3.0\n */\nimport * as utils from '@iobroker/adapter-core';\n\nimport Device, { isSupportedDeviceType, SupportedDeviceType } from './lib/types/device';\nimport Server from './server';\n\nclass SmartConnect extends utils.Adapter {\n    private server = null as Server | null;\n    private rootPath = '';\n    private stateSubscriptions = new Map<string, Set<(value: any) => void>>();\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'smart-connect',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n    private _verifyPath = (path: string): void => {\n        const isValid = path.startsWith(this.rootPath);\n        if (!isValid) {\n            throw new Error('Invalid path');\n        }\n    };\n\n    private async _getDevices(): Promise<Device[]> {\n        const objects = Object.values(await this.getForeignObjectsAsync(this.rootPath ? `*` : '*', 'channel'));\n\n        return objects\n            .filter(({ type, common: { role } }) => type === 'channel' && role && isSupportedDeviceType(role))\n            .map(({ _id, common, enums = {} }) => {\n                const roomName = Object.entries(enums).find(([enumId]) => enumId.startsWith('enum.rooms.'))?.[1];\n\n                return {\n                    id: _id,\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    name: common.name as string,\n                    type: common.role as SupportedDeviceType,\n                    roomName,\n                };\n            });\n    }\n\n    private async _getState(id: string): Promise<any> {\n        this._verifyPath(id);\n\n        const state = await this.getForeignStateAsync(id);\n        if (!state) {\n            throw new Error(`State ${id} not found`);\n        }\n\n        return state.val;\n    }\n\n    private async _setState(id: string, value: any): Promise<void> {\n        this._verifyPath(id);\n\n        await this.setForeignStateAsync(id, {\n            val: value,\n        });\n    }\n\n    private async _subscribeState(id: string, callback: (value: any) => void): Promise<void> {\n        this._verifyPath(id);\n\n        let subscriptions = this.stateSubscriptions.get(id);\n        if (!subscriptions) {\n            subscriptions = new Set([callback]);\n            this.stateSubscriptions.set(id, subscriptions);\n            await this.subscribeForeignStatesAsync(id);\n        } else {\n            subscriptions.add(callback);\n        }\n    }\n\n    private async _unsubscribeState(id: string, callback: (value: any) => void): Promise<void> {\n        this._verifyPath(id);\n\n        const subscriptions = this.stateSubscriptions.get(id);\n        if (!subscriptions) {\n            throw new Error(`No subscriptions for ${id}`);\n        }\n\n        subscriptions.delete(callback);\n        if (!subscriptions.size) {\n            this.stateSubscriptions.delete(id);\n            await this.unsubscribeForeignStatesAsync(id);\n        }\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        const { users, ip, port, rootPath, sessionSecret, allowedOrigins } = this.config;\n\n        this.rootPath = rootPath;\n\n        if (!sessionSecret) {\n            this.log.error('Session secret is not set');\n            throw new Error('Session secret is not set');\n        }\n\n        this.log.info(`Starting backend with ${users.length} users on ${ip}:${port}...`);\n        this.log.info(`Root path: ${rootPath}`);\n\n        const privateOrigins = allowedOrigins.filter((origin) => origin.private).map((origin) => origin.origin);\n        const publicOrigins = allowedOrigins.filter((origin) => !origin.private).map((origin) => origin.origin);\n\n        if (!privateOrigins.length && !publicOrigins.length) {\n            this.log.warn('No allowed origins are set');\n        } else {\n            this.log.info(\n                `Allowed origins: ${(privateOrigins.length ? privateOrigins : ['-']).join(\n                    ', ',\n                )} (private), ${(publicOrigins.length ? publicOrigins : ['-']).join(', ')} (public)`,\n            );\n        }\n        this.server = new Server(\n            users,\n            sessionSecret,\n            {\n                getDevices: this._getDevices.bind(this),\n                getState: this._getState.bind(this),\n                setState: this._setState.bind(this),\n                subscribeState: this._subscribeState.bind(this),\n                unsubscribeState: this._unsubscribeState.bind(this),\n            },\n            {\n                private: privateOrigins,\n                public: publicOrigins,\n            },\n        );\n\n        try {\n            await this.server.listen(port, ip);\n            this.log.info('Backend started');\n        } catch (e: any) {\n            this.log.error(`Could not start backend: ${e?.message || e}`);\n            throw e;\n        }\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            this.server?.close();\n        } catch (e) {\n        } finally {\n            callback();\n        }\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state) {\n            // The state was changed\n            this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n        } else {\n            // The state was deleted\n            this.log.info(`state ${id} deleted`);\n        }\n    }\n}\n\nif (require.main !== module) {\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new SmartConnect(options);\n} else {\n    (() => new SmartConnect())();\n}\n"],
  "mappings": "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",
  "names": ["Server"]
}
